#!/bin/bash
#
# Run write throughput benchmark
# Run on an existing Scylla cluster + loaders previously created by nyh/run2a3
set -ex

# Write Isolation Mode to use in the test - "forbid_rmw" (no LWT) or
# "always_use_lwt":
isolation=${isolation-forbid_rmw}

ec2-refresh

# Pick one of the Scylla nodes as the one to send administrative
# requests to:
scylla_api=http://`ec2-ips scylla-db | head -1`:8080

# Create the test table "usertable" (deleting it first if it exists)
# FIXME: need to delete the table without snapshots, which just wastes
# time on the server! If we can't configure Scylla properly, at least
# ssh to the server and delete the snapshots :-(
aws dynamodb delete-table \
    --endpoint-url $scylla_api \
    --table-name usertable || :
aws dynamodb create-table \
    --endpoint-url $scylla_api \
    --table-name usertable \
    --attribute-definitions \
        AttributeName=p,AttributeType=S \
    --key-schema \
        AttributeName=p,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST \
    --tags Key=system:write_isolation,Value=$isolation

loaders=(`ec2-ips loader`)
nodes=(`ec2-ips scylla-db`)

#cat <<END >/tmp/alternator-credentials
#accessKey = alternator
#secretKey = alternator_secret_access_key
#END

cat <<END >/tmp/alternator-credentials
accessKey = alternator
secretKey = alternator_secret_access_key
END
        
# CONTINUE HERE: save the loader output!
# CONTINUE HERE: calculate result from this output.

# Number of YCSB loaders to use per loader/server combination.
# In other words, each loader will run MULT*nservers ycsb processes, and each
# server will be loaded by MULT*nloaders ycsb processes.
# TODO: I don't understand why with say fieldcount=1 MULT=2 it takes a very
# long time to get higher results than MULT=1.
MULT=${MULT-1}

TMPDIR=/tmp/ssh1-$$
#trap 'rm -r /tmp/ssh1-$$' 0 1 2 3 15
mkdir $TMPDIR
echo keeping stats in $TMPDIR
trap 'rm -r /tmp/ssh1-$$' 1 2 3 15

for loader in ${loaders[@]}
do
    ec2-scp /tmp/alternator-credentials $loader:/tmp
    for node in ${nodes[@]}
    do
        for mult in `seq $MULT`
        do
            # For description of the following options, see
            # https://github.com/brianfrankcooper/YCSB/blob/master/dynamodb/conf/dynamodb.properties
            # NOTE: YCSB currently has two modes - "HASH" - with single-row
            # partitions - and "HASH_AND_RANGE" - where we have a *single*
            # partition and all the items in it. The HASH_AND_RANGE mode is
            # worthless for benchmarking because it has a single hot
            # partition.
            ec2-ssh $loader "cd ycsb-0.15.0; bin/ycsb -jvm-args='-Dorg.slf4j.simpleLogger.defaultLogLevel=OFF' run  dynamodb -P workloads/workloada -threads 100 \
            -p recordcount=1000000 \
            -p requestdistribution=uniform \
            -p fieldcount=${fieldcount-10} \
            -p fieldlength=${fieldlength-256} \
            -p readproportion=0 \
            -p updateproportion=0 \
            -p scanproportion=0 \
            -p insertproportion=1 \
            -p maxexecutiontime=${time-300} \
            -p operationcount=999999999 \
            -p measurementtype=hdrhistogram \
            -p dynamodb.endpoint=http://$node:8080 \
            -p dynamodb.connectMax=200 \
            -p requestdistribution=uniform \
            -p dynamodb.consistentReads=true \
            -p dynamodb.primaryKey=p \
            -p dynamodb.primaryKeyType=HASH \
            -p dynamodb.awsCredentialsFile=/tmp/alternator-credentials \
            -s" > $TMPDIR/$loader-$node-$mult 2>&1 &
        done
    done
done

# Wait for all the loaders started above to finish.
# TODO: catch interrupt and kill all the loaders.
wait

# Add the average (over the entire run) of the throughput of each loader.
# For the result to make sense, the loaders should all start and stop at
# roughly the same time, and the run must be long enough:
# * "time" of 300 (5 minutes) seems to give around 95% of the throughput
# * "time" of 600 (10 minutes) seems to give around 98% of the throughput
# A more accurate approach would be to calculate # the total throughput at
# each second and then graph (and average) those, but that's more complicated.
fgrep -h '[OVERALL], Throughput(ops/sec)' $TMPDIR/* |
    awk '{sum+=$3} END {print sum}'
